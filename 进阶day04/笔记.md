# 字符串函数

## string.h库

1.strlen(首字符地址)
>1.从首字符开始数数到'\0'停止 返回'\0'前面出现的字符个数(不包含'\0')
>2.参数指向的字符串必须要以'\0'结束
>3.函数返回值是无符号的

    int main()
    {
        /* code */
        char str[] = {'A', 'B', 'C'};
        printf("%d\n", strlen(str)); // 随机值
        // strlen()的返回值是unsigned long long类型 unsigned运算还是unsigned 表达式永远 > 0 -> 输出>
        if (strlen("abc") - strlen("abcdef") > 0)
        {
            /* code */
            printf(">\n");
        }
        else
        {
            /* code */
            printf("<=\n");
        }
    }

2.strcpy(目标地址,源地址)
>1.源字符串必须以'\0'结束
>2.会将源字符串中的'\0'拷贝到目标空间
>3.目标空间足够大,以确保能存放源字符串
>4.目标空间必须可变
>5.返回目标字符串的首地址

    int main(int argc, char const *argv[])
    {
        /* code */
        // 目标字符串必须可变
        char *str = "##########";
        char arr[] = "#####";
        // arr是指针(地址)不能存储字符串
        // arr = "hello";
        char *p = "hello";
        strcpy(arr,"hello");
        char arr1[3] = {'a','b','c'};
        // 程序崩了
        // strcpy(arr,arr1);
        return 0;
    }

3.strcat(目标地址,源地址)
>1.返回目标地址
>2.不能自己追加自己会死循环

    // 实现strcat()
    char *my_strcat(char *dest, const char *source)
    {
        assert(dest && source);
        char *ret = dest;
        // 1.找到\0
        while (*dest)
        {
            /* code */
            dest++;
        }
        // 2.追加源字符串
        while (*dest++ = *source++)
        {
            /* code */
            ;
        }
        return ret;
    }

    int main()
    {
        /* code */
        char arr[20] = "hello ";
        char arr1[] = "world";
        strcat(arr, arr1);
        printf("%s\n", arr);
        char arr2[20] = "hello ";
        char arr3[] = "world";
        my_strcat(arr2, arr3);
        printf("%s\n", arr2);
        return 0;
    }

4.strcmp(目标地址,源地址)
>1.返回目标地址
>2.比较字符的ASCII码值 相等就比较下一个

    // 实现strcmp()
    int my_strcmp(const char *str1, const char *str2)
    {
        assert(str1 && str2);
        while (*str1 == *str2)
        {
            /* code */
            if (*str1 == '\0')
            {
                /* code */
                break;
            }
            str1++;
            str2++;
        }
        return *str1 - *str2;
    }

    int main()
    {
        /* code */
        char p[] = "abcdef";
        char q[] = "abqb";
        // 比较的是指针的大小
        if (p > q)
        {
            /* code */
            printf("p > q\n");
        }
        else
        {
            /* code */
            printf("p <= q\n");
        }
        // 比较的是首字符的地址
        if ("abc" > "abcdef")
        {
            /* code */
            printf("abc > abcdef\n");
        }
        else
        {
            /* code */
            printf("abc <= abcdef\n");
        }
        // 用strcmp()函数
        if (strcmp(p, q) < 0)
        {
            /* code */
            printf("str1 < str2\n");
        }
        else if (strcmp(p, q) > 0)
        {
            /* code */
            printf("str1 > str2\n");
        }
        else
        {
            /* code */
            printf("str1 = str2\n");
        }
        // 用my_strcmp()函数
        if (my_strcmp(p, q) < 0)
        {
            /* code */
            printf("str1 < str2\n");
        }
        else if (my_strcmp(p, q) > 0)
        {
            /* code */
            printf("str1 > str2\n");
        }
        else
        {
            /* code */
            printf("str1 = str2\n");
        }

        return 0;
    }

>strcpy、strcat、strcmp长度不受限制的字符串函数
>strncpy、strncat、strncmp长度受限制的字符串函数

    int main()
    {
        /* code */
        char arr1[20] = "abcdef";
        char arr2[] = "qwer";
        // 只是相对比strcpy()安全
        // 如果长度不够会补'\0'
        strncpy(arr1, arr2, 2);
        printf("%s\n", arr1); // qwcdef
        // 如果长度不够也会结束 以'\0'为结尾 追加完以'\0'为结尾
        strncat(arr1, arr2, 3);
        printf("%s\n", arr1); // qwcdefqwe
        // strncmp()可以指定比较字符个数
        printf("%d\n", strncmp(arr1, arr2, 3)); // qwcdefqwe
        return 0;
    }