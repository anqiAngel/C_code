# 字符串函数

## string.h库

1.strlen(首字符地址)
>1.从首字符开始数数到'\0'停止 返回'\0'前面出现的字符个数(不包含'\0')
>2.参数指向的字符串必须要以'\0'结束
>3.函数返回值是无符号的

    int main()
    {
        /* code */
        char str[] = {'A', 'B', 'C'};
        printf("%d\n", strlen(str)); // 随机值
        // strlen()的返回值是unsigned long long类型 unsigned运算还是unsigned 表达式永远 > 0 -> 输出>
        if (strlen("abc") - strlen("abcdef") > 0)
        {
            /* code */
            printf(">\n");
        }
        else
        {
            /* code */
            printf("<=\n");
        }
    }

2.strcpy(目标地址,源地址)
>1.源字符串必须以'\0'结束
>2.会将源字符串中的'\0'拷贝到目标空间
>3.目标空间足够大,以确保能存放源字符串
>4.目标空间必须可变
>5.返回目标字符串的首地址

    int main(int argc, char const *argv[])
    {
        /* code */
        // 目标字符串必须可变
        char *str = "##########";
        char arr[] = "#####";
        // arr是指针(地址)不能存储字符串
        // arr = "hello";
        char *p = "hello";
        strcpy(arr,"hello");
        char arr1[3] = {'a','b','c'};
        // 程序崩了
        // strcpy(arr,arr1);
        return 0;
    }

3.strcat(目标地址,源地址)
>1.返回目标地址
>2.不能自己追加自己会死循环

    // 实现strcat()
    char *my_strcat(char *dest, const char *source)
    {
        assert(dest && source);
        char *ret = dest;
        // 1.找到\0
        while (*dest)
        {
            /* code */
            dest++;
        }
        // 2.追加源字符串
        while (*dest++ = *source++)
        {
            /* code */
            ;
        }
        return ret;
    }

    int main()
    {
        /* code */
        char arr[20] = "hello ";
        char arr1[] = "world";
        strcat(arr, arr1);
        printf("%s\n", arr);
        char arr2[20] = "hello ";
        char arr3[] = "world";
        my_strcat(arr2, arr3);
        printf("%s\n", arr2);
        return 0;
    }

4.strcmp(目标地址,源地址)
>1.返回目标地址
>2.比较字符的ASCII码值 相等就比较下一个

    // 实现strcmp()
    int my_strcmp(const char *str1, const char *str2)
    {
        assert(str1 && str2);
        while (*str1 == *str2)
        {
            /* code */
            if (*str1 == '\0')
            {
                /* code */
                break;
            }
            str1++;
            str2++;
        }
        return *str1 - *str2;
    }

    int main()
    {
        /* code */
        char p[] = "abcdef";
        char q[] = "abqb";
        // 比较的是指针的大小
        if (p > q)
        {
            /* code */
            printf("p > q\n");
        }
        else
        {
            /* code */
            printf("p <= q\n");
        }
        // 比较的是首字符的地址
        if ("abc" > "abcdef")
        {
            /* code */
            printf("abc > abcdef\n");
        }
        else
        {
            /* code */
            printf("abc <= abcdef\n");
        }
        // 用strcmp()函数
        if (strcmp(p, q) < 0)
        {
            /* code */
            printf("str1 < str2\n");
        }
        else if (strcmp(p, q) > 0)
        {
            /* code */
            printf("str1 > str2\n");
        }
        else
        {
            /* code */
            printf("str1 = str2\n");
        }
        // 用my_strcmp()函数
        if (my_strcmp(p, q) < 0)
        {
            /* code */
            printf("str1 < str2\n");
        }
        else if (my_strcmp(p, q) > 0)
        {
            /* code */
            printf("str1 > str2\n");
        }
        else
        {
            /* code */
            printf("str1 = str2\n");
        }

        return 0;
    }

>strcpy、strcat、strcmp长度不受限制的字符串函数
>strncpy、strncat、strncmp长度受限制的字符串函数

    int main()
    {
        /* code */
        char arr1[20] = "abcdef";
        char arr2[] = "qwer";
        // 只是相对比strcpy()安全
        // 如果长度不够会补'\0'
        strncpy(arr1, arr2, 2);
        printf("%s\n", arr1); // qwcdef
        // 如果长度不够也会结束 以'\0'为结尾 追加完以'\0'为结尾
        strncat(arr1, arr2, 3);
        printf("%s\n", arr1); // qwcdefqwe
        // strncmp()可以指定比较字符个数
        printf("%d\n", strncmp(arr1, arr2, 3)); // qwcdefqwe
        return 0;
    }

5.strstr(字符串1,字符串2)判断子串函数 匹配到了返回首次匹配的地址 没匹配到返回NULL

    // 暴力实现strstr()
    char *my_strstr1(const char *str1, const char *str2)
    {
        assert(str1 && str2);
        const char *s1 = NULL;
        const char *s2 = NULL;
        const char *cp = str1;
        if (*str2 == '\0')
        {
            /* code */
            return (char*)str1;
        }
        
        while (*cp)
        {
            /* code */
            s1 = cp;
            s2 = str2;
            while (*s2 && (*s1 == *s2))
            {
                /* code */
                s1++;
                s2++;
            }
            if (*s2 == '\0')
            {
                /* code */
                return (char*)cp;
            }
            cp++;
        }
        return NULL;

    }
    int main()
    {
        /* code */
        char arr1[] = "defdef";
        char arr2[] = "def";
        // 存在返回的是arr1第一次匹配到arr2的地址 不存在返回NULL
        printf("%s\n", my_strstr1(arr1, arr2));
        return 0;
    }

6.strtok(要切割的字符串,分割字符集合(字符串))函数 字符串切割函数
>1.第一个参数指定一个字符串,它包含了0个或多个seq字符串中的字符
>2.每次找到一个分割字符并改成'\0',返回分割出的字符串的首地址 保存找到分割符的地址('\0'的地址) 下次从这个地址开始分割
>3.strtok(要切割的字符串,分割字符集合(字符串))函数会改变字符串 一般复制一个副本进行分割
>4.找到返回首地址,找不到返回NULL

    int main()
    {
        /* code */
        // strtok(要切割的字符串,分割字符集合(字符串))函数 字符串切割函数
        char str1[] = "www.baidu.com";
        char *sep = ".";
        // 创建str1的副本
        char str2[] = "";
        strcpy(str2, str1);
        printf("%s\n", str2);
        // printf("%s\n", strtok(str2, sep));
        // printf("%s\n", strtok(NULL, sep));
        // printf("%s\n", strtok(NULL, sep));
        char* ret = NULL; 
        // 用for循环分割
        for (ret = strtok(str2, sep); ret != NULL; ret = strtok(NULL, sep))
        {
            /* code */
            printf("%s\n",ret);
        }
        
        return 0;
    }

6.strtok(错误码)
>返回错误码,对应的错误信息

int main()
{
    /*code*/
    // 打开文件 成功返回文件指针 打开失败返回NULL
    FILE *fp = fopen("./demo11.c", "r");
    // 打印错误码
    if (!fp)
    {
        /* code */
        printf("错误是:%s\n",strerror(errno)); // No such file or directory
    }else
    {
        /* code */
        printf("没错\n");
    }
    // perror打印错误
    //将错误码转化为错误信息并打印
    perror("perror打印的错误是");
    fclose(fp);
    fp = NULL;
    return 0;
}

## 字符相关的函数

>1.字符分类函数iscntrl、isspace、isdigit、isupper、islower...
>2.字符转化函数 toupper、tolower...

    #include <stdio.h>
    #include <string.h>
    #include <ctype.h>

    int main()
    {
        /* code */
        // char c1 = '1';
        char c1 = 'b';
        // isdigit(字符) 是数字字符返回非0值 不是返回0
        // int ret = isdigit(c1);
        // islower(字符) 是小写字母字符返回非0值 不是返回0
        int ret = islower(c1);
        // 或者
        if (c1 >= 'a' && c1 <= 'z')
        {
            /* code */
            printf("是小写字母\n");
        }
        printf("%d\n", ret);
        char str1[] = "abcdef";
        // 将str1转化为大写字符串
        for (int i = 0; i < strlen(str1); i++)
        {
            /* code */
            *(str1 + i) = toupper(*(str1 + i));
        }
        printf("%s\n", str1);
        return 0;
    }

## 内存函数

1.memcpy(目标地址,源地址,大小) 一般不能处理有重复的情况 有些环境可以如vs编译器
>1.拷贝任意类型的元素 源地址->目标地址

    // 实现memcpy()
    void *my_memcpy(void *dest, const void *source, unsigned int num)
    {
        assert(dest && source);
        for (int i = 0; i < num; i++)
        {
            /* code */
            // void *不能直接解引用和运算
            *((char *)dest + i) = *((char *)source + i);
        }
        return dest;
    }

    int main()
    {
        /* code */
        int arr1[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int arr2[20] = {0};
        // 拷贝arr1前5个元素(20字节)到arr2
        memcpy(arr2, arr1, 20);
        for (int i = 0; i < 5; i++)
        {
            /* code */
            printf("%d ", arr2[i]);
        }
        printf("\n");
        // 拷贝arr1前5个元素(20字节)到arr2
        my_memcpy(arr2, arr1, 40);
        for (int i = 0; i < 10; i++)
        {
            /* code */
            printf("%d ", arr2[i]);
        }
        printf("\n");
        return 0;
    }

2.memmove(目标地址,源地址,大小) 可以处理有重复的情况
>1.拷贝任意类型的元素 源地址->目标地址

    // 实现memmove()函数 可以处理内存重叠的情况
    void *my_memmove(void *dest, const void *source, unsigned int num)
    {
        assert(dest && source);
        if (dest < source)
        {
            /* code */
            for (int i = 0; i < num; i++)
            {
                /* code */
                // 前 -> 后
                *((char *)dest + i) = *((char *)source + i);
            }
        }
        else
        {
            /* code */
            for (int i = num - 1; i >= 0; i--)
            {
                /* code */
                // 后 -> 前
                *((char *)dest + i) = *((char *)source + i);
            }
        }
        return dest;
    }

    int main()
    {
        /* code */
        int arr1[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        // memmove()函数可以处理内存重叠的情况
        my_memmove(arr1 + 2, arr1, 20);
        for (int i = 0; i < 10; i++)
        {
            /* code */
            printf("%d ", arr1[i]);
        }
        printf("\n");
        return 0;
    }

3.memcmp(目标地址,源地址,大小) 可以处理有重复的情况
>1.比较任意类型的元素
>2.memcmp(内容1指针,内容2指针,大小)内存比较函数 与strcmp()返回值相同
>3.函数返回值 如果比较的两个内容相等返回0,内容1>内容2 返回大于0的数,内容1<内容2 返回小于0的数

    int main()
    {
        /* code */
        // memcmp(内容1指针,内容2指针,大小)内存比较函数 与strcmp()返回值相同
        // 函数返回值 如果比较的两个内容相等返回0,内容1>内容2 返回大于0的数,内容1<内容2 返回小于0的数
        float arr[] = {0.0, 1.0, 2.0};
        float arr1[] = {0.0, 2.0, 3.0};
        int ret = memcmp(arr, arr1, 4);
        int ret1 = memcmp(arr, arr1, 8);
        printf("%d\n", ret); // 0
        printf("%d\n", ret1); // 1
        return 0;
    }

4.memset(指针,内容,大小) 将指针指向的空间设为指定值
>1.以字节为单位设置内存
    int main()
    {
        /*code*/1
        // memset(指针,内容,大小) 将指针指向的空间设为指定值
        int arr2[10] = {0};
        // 按字节操作
        memset(arr2, 1, 20);
        for (int i = 0; i < 10; i++)
        {
            /*code*/
            printf("%d ",arr2[i]);
        }
        printf("\n");
        return 0;
    }

## 这些函数非常重要
