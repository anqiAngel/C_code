# Debug版本和Release版本  

Release版本对Debug版本做了一些优化 修复了Debug版本中的一些错误

---

# 数据存储

## 数据类型  

整型:char、short、int、long、long long
char:1.unsigned char 2.signed char
short:1.unsigned short 2.signed short 
int:1.unsigned int 2.signed int
long:1.unsigned long 2.signed long
浮点型:float、double
构造类型(自定义类型):数组、结构体struct、联合体union、枚举enum
指针类型pointer
空类型void

## 整型

数据在内存中以二进制的形式来存储
对于整数来说在内存中有三种表示形式:原码、反码、补码
正整数:原、反、补相同
负整数:反码符号位不变按位取反,反码+1得到补码 补码到原码:1.补码-1,符号位不变按位取反 2.补码符号位不变按位取反+1得到原码
整数在内存中存储的是补码
CPU只有加法器没有减法器所以算1-1时使用1+(-1)
补码作用:1.将数值位与符号位统一 2.加法和减法统一处理

字节序:字节的存储顺序
int a = 0x11223344; 字节序由高到低 高->低
大端小端存储:1.大端字节序:低位字节序内容存在高地址处,高位字节序内容存在低地址处 2.小端字节序:低位字节序内容存在低地址处,高位字节序内容存在高地址处

---
指针加1地址增加多少
char型:+1 short型+2 int型 +4 ...
指针解引用访问字节数
*char访问1个字节 *short访问2个字节 *int访问4个字节
整型提升看存储类型unsigned的在前面补0 signed看符号为正数补0负数补1

---
    /* code */
    char a = -1;
    signed char b = -1;
    // 存储补码11111111111111111111111111111111
    // 取出unsigned char 补码整型提升->00000000000000000000000011111111 -> 255
    unsigned char c = -1;
    // 存储补码 原码10000000000000000000000000000010 -> 反码11111111111111111111111111111101 -> 补码11111111111111111111111111111110
    // 取出unsigned char 补码整型提升->00000000000000000000000011111110 -> 254
    unsigned char d = -2;
    // 存储补码 原码10000000000000000000000000000011 -> 反码11111111111111111111111111111100 -> 补码11111111111111111111111111111101
    // 取出unsigned char 补码整型提升->00000000000000000000000011111101 -> 253
    unsigned char e = -3;
    printf("%d %d %d %d %d\n", a, b, c, d, e);
补充:1.char 到底是signed char 还是 unsigned char?
C语言标准并没有规定 这个与编译器有关不同编译器不一定相同
int 是signed int
short 是signed short

---
    char f = -128;
    // 存储补码 原码10000000000000000000000010000000 -> 反码11111111111111111111111101111111 -> 补码11111111111111111111111110000000
    // 取出char 补码整型提升->11111111111111111111111110000000 unsigned int打印 无符号位直接转为10进制 4294967168
    printf("%u\n",f);
    char g = 128;
    // 存储补码 补码00000000000000000000000010000000
    // 取出char 补码整型提升->11111111111111111111111110000000 unsigned int打印 无符号位直接转为10进制 4294967168
    printf("%u\n",g);
char类型的取值范围 -128 - 127
char类型的值在-128-127循环 -128 + 1 = 0 127 + 1 = -128 
内存中补码10000000是 -128

---
    /* code */
    // 原码10000000000000000000000000010100 -> 反码11111111111111111111111111101011->补码11111111111111111111111111101100 
    int i = -20;
    // 补码00000000000000000000000000001010
    unsigned int j = 10;
    // i + j 11111111111111111111111111110110 -> 11111111111111111111111111110101 -> 10000000000000000000000000001010 -> -10
    printf("%d\n",i + j);
    // 一个 unsigned int和int计算会将int转换为unsigned int
    // i > 0 j > 0
    if (i + j > 0)
    {
        /* code */
        printf("大于0\n");
    }else{
        /* code */
        printf("小于0\n");
    } 
---
unsigned 类型的变量是>=0的

    // 死循环
    unsigned int k;
    for (k = 0; k >= 0; k--)
    {
        /* code */
        printf("真好玩\n");
    }
---
char、short、int -> 在limits.h中定义取值范围
float、double -> 在float.h中定义取值范围

    /* code */
    // 本质上是把首字符的地址存储在了str中
    // 最好加上const
    const char* str = "hello bit";
    // *str = 'a';
    // 常量改变不了
    // 数组名是字符串首字符的地址
    char str1[] = "hello bit"; 
    printf("%c\n",*str);
    printf("%c\n",*str1);
    // 打印字符串只需要首地址 就可以打印字符串
    printf("%s\n",str);
    printf("%s\n",str1);
    return 0;
---

