# Debug版本和Release版本  

Release版本对Debug版本做了一些优化 修复了Debug版本中的一些错误

---

# 数据存储

## 数据类型  

整型:char、short、int、long、long long
char:1.unsigned char 2.signed char
short:1.unsigned short 2.signed short 
int:1.unsigned int 2.signed int
long:1.unsigned long 2.signed long
浮点型:float、double
构造类型(自定义类型):数组、结构体struct、联合体union、枚举enum
指针类型pointer
空类型void

## 整型

数据在内存中以二进制的形式来存储
对于整数来说在内存中有三种表示形式:原码、反码、补码
正整数:原、反、补相同
负整数:反码符号位不变按位取反,反码+1得到补码 补码到原码:1.补码-1,符号位不变按位取反 2.补码符号位不变按位取反+1得到原码
整数在内存中存储的是补码
CPU只有加法器没有减法器所以算1-1时使用1+(-1)
补码作用:1.将数值位与符号位统一 2.加法和减法统一处理

字节序:字节的存储顺序
int a = 0x11223344; 字节序由高到低 高->低
大端小端存储:1.大端字节序:低位字节序内容存在高地址处,高位字节序内容存在低地址处 2.小端字节序:低位字节序内容存在低地址处,高位字节序内容存在高地址处

---
指针加1地址增加多少
char型:+1 short型+2 int型 +4 ...
指针解引用访问字节数
*char访问1个字节 *short访问2个字节 *int访问4个字节
整型提升看存储类型unsigned的在前面补0 signed看符号为正数补0负数补1

---
    /* code */
    char a = -1;
    signed char b = -1;
    // 存储补码11111111111111111111111111111111
    // 取出unsigned char 补码整型提升->00000000000000000000000011111111 -> 255
    unsigned char c = -1;
    // 存储补码 原码10000000000000000000000000000010 -> 反码11111111111111111111111111111101 -> 补码11111111111111111111111111111110
    // 取出unsigned char 补码整型提升->00000000000000000000000011111110 -> 254
    unsigned char d = -2;
    // 存储补码 原码10000000000000000000000000000011 -> 反码11111111111111111111111111111100 -> 补码11111111111111111111111111111101
    // 取出unsigned char 补码整型提升->00000000000000000000000011111101 -> 253
    unsigned char e = -3;
    printf("%d %d %d %d %d\n", a, b, c, d, e);
补充:1.char 到底是signed char 还是 unsigned char?
C语言标准并没有规定 这个与编译器有关不同编译器不一定相同
int 是signed int
short 是signed short

---
    char f = -128;
    // 存储补码 原码10000000000000000000000010000000 -> 反码11111111111111111111111101111111 -> 补码11111111111111111111111110000000
    // 取出char 补码整型提升->11111111111111111111111110000000 unsigned int打印 无符号位直接转为10进制 4294967168
    printf("%u\n",f);
    char g = 128;
    // 存储补码 补码00000000000000000000000010000000
    // 取出char 补码整型提升->11111111111111111111111110000000 unsigned int打印 无符号位直接转为10进制 4294967168
    printf("%u\n",g);
char类型的取值范围 -128 - 127
char类型的值在-128-127循环 -128 + 1 = 0 127 + 1 = -128 
内存中补码10000000是 -128

---
    /* code */
    // 原码10000000000000000000000000010100 -> 反码11111111111111111111111111101011->补码11111111111111111111111111101100 
    int i = -20;
    // 补码00000000000000000000000000001010
    unsigned int j = 10;
    // i + j 11111111111111111111111111110110 -> 11111111111111111111111111110101 -> 10000000000000000000000000001010 -> -10
    printf("%d\n",i + j);
    // 一个 unsigned int和int计算会将int转换为unsigned int
    // i > 0 j > 0
    if (i + j > 0)
    {
        /* code */
        printf("大于0\n");
    }else{
        /* code */
        printf("小于0\n");
    } 
---
unsigned 类型的变量是>=0的

    // 死循环
    unsigned int k;
    for (k = 0; k >= 0; k--)
    {
        /* code */
        printf("真好玩\n");
    }
---
char、short、int -> 在limits.h中定义取值范围
float、double -> 在float.h中定义取值范围

    /* code */
    // 本质上是把首字符的地址存储在了str中
    // 最好加上const
    const char* str = "hello bit";
    // *str = 'a';
    // 常量改变不了
    // 数组名是字符串首字符的地址
    char str1[] = "hello bit"; 
    printf("%c\n",*str);
    printf("%c\n",*str1);
    // 打印字符串只需要首地址 就可以打印字符串
    printf("%s\n",str);
    printf("%s\n",str1);
    return 0;
---
数据的存储得看存储类型,取出得看取出类型

## 浮点型

3.1415926 1E10->1.0*10的10次方 浮点数家族包括float、double、long double类型

    /* code */
    int n = 9;
    float* pFloat = (float*)&n; 
    printf("n的值为:%d\n",n); // 9
    printf("*pFloat的值为:%f\n",*pFloat); // 0.000000
    *pFloat = 9.0;
    printf("num的值为:%d\n",n); // 1091567616
    printf("*pFloat的值为:%f\n",*pFloat); // 9.000000
说明内存中整数的存储方式与浮点数的存储方式不同
IEEE 754标准规定 任意一个二进制浮点数V可以表示成下面的形式:

- (-1)\^S\*M\*2^E
- (-1)^S表示符号位,当S=0,V为正数;当S=1,V为负数。
- M表示有效数字,大于等于1,小于2。
- 2^E表示指数位 

浮点数:5.5 - 10进制
二进制:101.1 -> 1.011*2^2 二进制的科学计数法 (-1)\^0\*1.011\*2^2
单精度浮点数存储模型:
![Alt text](%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.jpg)
双精度浮点数存储模型:
![Alt text](%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.jpg)
S是符号位
E是指数位+一个中间值 中间值:float 8位E +127,double 11位E +1023
浮点数的取出

- E不全0或不全1时 E值减去中间值还原
- E全为0时  真实值太小了接近0 直接1-127或1-1023还原
- E全为1时  真实值很大的数+-M 表示+-无穷大

---

