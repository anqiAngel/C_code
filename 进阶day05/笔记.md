# 自定义类型

>自定义类型:结构体、枚举、联合

## 结构体

>结构体是一些值的集合,这些值称为成员变量。结构的每个成员可以时不同类型的变量。是一种复杂的类型。

    // 定义一个书结构 声明一个结构体
    struct Book
    {
        /* data */
        char name[20];
        char id[20];
        int price;
    } book1 = {"红楼梦", "3", 20}, book2 = {"水浒传", "4", 20}; // 声明结构体变量并初始化

    // 匿名结构体 没有结构体标签名字 不完全声明结构体 只能使用一次
    struct
    {
        /* data */
        int id;
        char name[20];
    } s;

    // 匿名结构体指针
    struct
    {
        /* data */
        int id;
        char name[20];
    } *ps;

    // 结构体的引用
    struct A
    {
        /* data */
        int i;
        char c;
    };

    struct B
    {
        /* data */
        char c;
        struct A sa;
        double d;
    };
    // 不可以 必须先有类型再重命名
    typedef struct
    {
        /* data */
        int data;
        Node *next;
    } Node;

    int main()
    {
        /* code */
        // 结构体初始化
        struct Book book3 = {"西游记", "1", 20};
        struct Book book4 = {"三国演义", "2", 20};
        // ps = &s; // 会出现问题 编译器会将他们理解为不同的类型
        return 0;
    }

结构体的自引用 在结构体里包含同类型的指针 结点能够找到同类型的下一个结点

    // 结构体的自引用
    // 链表结点定义
    struct N
    {
        /* data */
        // 数据域
        int i;
        // 死循环不可以
        // struct N sn;
        // 地址域
        struct N *sn;
    };

## 结构体内存大小计算

>结构体内存对齐
>1.结构体的第一个成员,放在结构体在内存中存储位置的0偏移处开始
>2.从第2个成员往后的所有成员,都放在对齐数(成员的大小、默认对齐数二者的较小值)的整数倍的地址处
>3.结构体的总大小是结构体的所有成员的对齐数中最大的那个对齐数的整数倍
>4.VS编译器默认对齐数是8 Linux没有这个概念
>5.如果嵌套了结构体的情况,嵌套的结构体对齐到自己的最大对齐数的整数倍处,结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍

## 为什么存在内存对齐

>1.平台原因(移植原因):不是所有的硬件平台都能访问任意地址上的任意数据,有些硬件平台只能在某些地址处取某些特定类型的数据,否则抛出异常
>2.性能原因:数据结构(尤其是栈)应该尽可能地在自然边界上对齐 原因在于,为了访问未对齐的内存,处理器需要做两次内存访问;而对齐的内存访问仅需要一次访问。对齐提高了数据的访问效率 内存对齐的访问效率高
>总的来说结构体的内存对齐是拿空间换时间的做法
>设计结构体的一些原则:1.占用空间小的成员放在一起

设置默认对齐数的方法

    #pragma pack(2) 设置默认对齐数是2 一般不会设置奇数
    结构体定义 
    #pragma pack() 把对齐数改回来 还原默认

## offsetof宏

>offsetof(结构体,结构体成员) 用于计算成员变量相较于结构体起始位置的偏移量

## 结构体传参

>1.传值开销大速度慢 性能下降
>2.传址开销小速度快 结构体传参尽量传址

## C语言中的位段

>与结构体类似 为了节省空间 位段设计合适可以达到同样的效果 但是跨平台性不好 一个平台一个样不好控制
>位段典型应用IP数据包

## 枚举

>枚举一一列举 把可能取值一一列举 经常与 #define对标 可以增加代码的可读性
>>1.周一到周四可以一一列举
>>2.男女可以一一列举
>>3.月份12个月可以一一列举
>>4.一种新的类型 取值是有限的
>>慢慢感受

    enum 类型名{
        可能取值1,
        可能取值2
    };

>枚举的优点
>>1.增加代码的可读性和可维护性
>>2.和#define定义的标识符比较枚举有类型检查,更加严谨
>>3.防止了命名污染(封装)
>>4.便于调试 #define 是用于替换的 在预编译时就替换了
>>5.使用方便,一次可以定义多个常量

## 联合体(共用体)

>联合体又称共用体 联合体成员共用内存空间 改i可能会改变c 改c可能会改变i 同一时间值只能用一个值
>> 初始化一个成员 这个结构体就初始化了

    // 联合体的定义
    union Un
    {
        /* data */
        char c; // 占一个字节
        int i;  // 占四个字节 第一个字节与 char c公用
        // 改i可能会改变c 改c可能会改变i
    };

    // 检查系统是大端存储还是小端存储 结构体解法
    int check_sys(){

        union Un
        {
            /* data */
            char c;
            int i;
        } u;
        u.i = 1;
        if (u.c == 1)
        {
            /* code */
            // 小端返回0
            return 0;
        }else
        {
            /* code */
            // 大端返回1
            return 1;
        }
        
    }
        
    int main(int argc, char const *argv[])
    {
        /* code */
        union Un u;
        printf("%p\n",&u); 
        printf("%p\n",&(u.c));
        printf("%p\n",&(u.i));
        printf("%d\n",sizeof(u)); // 4
        if (check_sys())
        {
            /* code */
            printf("大端存储\n");
        }else
        {
            /* code */
            printf("小端存储\n");
        }
        return 0;
    }

>联合体大小计算
>>1.联合体的大小是至少是最大成员的大小
>>2.当最大成员大小不是最大对齐数的整数倍的时候,就要对齐到最大对齐数的整数倍处
