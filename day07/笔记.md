# day07

比较两个字符串相等不能用==  一般用string.h中的strcmp(a,b)函数  
int e = (a+1,b+a+1); 逗号表达式从左向右依次计算表达式的值 值取最右端表达式的值  
整型提升:char、short在运算时会发生整形提升(隐式类型转换)小于整型的类型  
算术转换:int->float int->double
我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径,那这个表达式就是存在问题的  

# 指针

指针(pointer):指针是变量用来存放地址 存放地址的是指针变量 取地址取的是首字节的地址  
指针的大小在32位平台上是4个字节,在64位平台上是8个字节  

## 指针和指针类型

指针变量(char short int float)都占4个字节 但指针类型是有意义的  
1.指针类型决定了:指针解引用的权限有多大  
2.指针类型决定了,指针走一步能走多远(步长)  
int *p加1跳过4个字节
char* p加1跳过1个字节  
int *p* p解引用时访问4个字节  。
char *p* p解引用时访问1个字节  

## 野指针

野指针:野指针就是指针指向的位置是不可知的(随机的、不正确的、没有明确限制的)  
野指针的几种情况(非法访问内存):  

1. int *p;*p = 20; *p是随机的空间  
2. 越界访问 访问不属于访问内容的空间  
3. 指针指向的空间已经被释放了  

避免野指针  

1. 定义指针变量要初始化 不知道初始化为什么时初始化为NULL  
2. 小心指针越界  
3. 指针指向的空间被释放时指针及时置空NULL
4. 指针使用之前检查有效性  

## 指针运算

1. 指针+-整数 得到另一个指针
2. 指针-指针  得到的是两个指针之间的元素个数 指针和指针相减前提是两个指针指向同一块空间
3. 指针的关系运算  
4. 指针+指针没什么意义
int * p = arr
arr[2] = 2[arr] = p[2] = 2[p]

## 二级指针

int a = 10
int * pa = &a
ppa是就是一个二级指针变量 &pa取出pa在内存中的起始地址
int **ppa = &pa  

## 指针数组

指针数组:数组中元素是地址(指针)
int* pa[5] = {&a};

---
# 结构体

## 结构体定义

    struct people
    {
        /* data */
        // 结构体成员 声明变量 类型 + 变量名
        int id;
        char name[20];
    }p1={1,"张三"};

    struct student
    {
        /* data */
        struct people p; // 可以嵌套结构体
        int age;
        char phone_number[20];
    }stu1={{2,"李四"},18,"10086"}; // 可以立刻创建结构体变量并初始化

## 结构体的初始化

    // 结构体用{}初始化 可以嵌套
    struct student stu2 = {{3,"王五"},18,"10010"};

## 结构体的访问

    struct student* p1 = &stu2;
    // 结构体成员的访问 结构体变量名(对象名).结构体成员变量名
    printf("%d %s %d %s\n",stu2.p.id,stu2.p.name,stu2.age,stu2.phone_number);
    // 指针访问 指针->结构体成员名
    printf("%d %s %d %s\n",p1->p.id,p1->p.name,p1->age,p1->phone_number);
